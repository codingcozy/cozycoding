---
title: "모든 프로그래머가 마스터해야 할 필수적인 증명 기법 5가지"
description: ""
coverImage: "/assets/img/2024-07-10-FundamentalProofTechniquesEveryProgrammerShouldMaster_0.png"
date: 2024-07-10 03:44
ogImage: 
  url: /assets/img/2024-07-10-FundamentalProofTechniquesEveryProgrammerShouldMaster_0.png
tag: Tech
originalTitle: "Fundamental Proof Techniques Every Programmer Should Master"
link: "https://medium.com/@pepitoscrespo/very-basic-proof-based-mathematics-every-average-programmer-should-know-2c307f7dc664"
isUpdated: true
---





![Image](/assets/img/2024-07-10-FundamentalProofTechniquesEveryProgrammerShouldMaster_0.png)

While this method might be enforced by the deceptive giant corporations, commonly known as FAANGs, it comes with notable drawbacks, especially when tackling intricate real-world engineering dilemmas that demand a more profound comprehension of various, less restrictive proof methodologies.

For instance, numerous engineering challenges, particularly in domains such as systems design, network theory, and cryptography, necessitate non-constructive proofs, which typically go beyond the scope of conventional LeetCode exercises. These encompass proofs executed through methods like:

#1. Proof by Contradiction


<div class="content-ad"></div>

가정과 반대되는 것을 전제로 삼아 모순에 이르게 되는 것을 증명함으로써 원래의 주장을 입증합니다. 이것이 필요한 분야는:

- 사이버 보안
- 회로 설계
- 구조 공학

## 2. 축소에 의한 증명

문제가 다른 이미 해결된 또는 미해결된 문제로 변환될 수 있음을 보여주어 한 문제의 어려움을 이용하여 다른 문제의 어려움을 확립합니다. 이러한 방법은 다음 분야에서 찾을 수 있습니다:

<div class="content-ad"></div>

- 알고리즘 트레이딩
- 소프트웨어 테스팅
- 계산 생물학

**3. 확률적 증명**

확률 이론을 활용하여 특정 문장이 사실인 가능성을 확립하며, 일반적으로 속성이 일반적으로 유효하거나 대부분 시간에 유지됨을 확인하는 데 자주 사용됩니다.

- 네트워크 신뢰성
- 인공 지능
- 품질 관리

<div class="content-ad"></div>

# 4. Existential Proofs

안 만들어도 객체나 속성의 존재를 증명하는 방법을 간접적으로 증명하거나 비존재가 모순으로 이어지는 것을 보여줌.

- 재료 과학
- 양자역학
- 환경공학

# 5. Proof by Induction

<div class="content-ad"></div>

카운트 가능한 모든 경우에 대한 명제를 입증하기 위해 가장 작은 경우에 대해 확인하고 임의의 경우 n이 성립하면 n+1에 대해서도 성립함을 보여주는 방법을 사용합니다.

- 소프트웨어 엔지니어링
- 전기 공학
- 통신

이러한 기본적인 수학 증명 방법들은 가장 수익성 높은 엔지니어링 문제들에 대한 해결책이 Anti-LeetCode를 기반으로 해야 하며, 상한선과 하한선을 찾는 데 초점을 맞추고 요리 레시피의 이산적 단계에 집중하지 않아야 함을 보여줍니다.

양자 컴퓨팅, 알고리즘 게임 이론, 운영 연구, 소프트웨어 검증 재료 과학, 계산 유체 역학 등에서 이러한 종류의 증명에 크게 의존하는 다른 분야들이 있습니다. 이러한 분야들에서 비구성적인 증명은 종종 NP-난제인 여러 가장 급박하고 수익성 높은 엔지니어링 도전에 대처하는 데 필수적이며, 이는 LeetCode 문제에서 주로 만나는 P-완전 문제와는 다릅니다. 이러한 괴리는 상당수 프로그래머들의 교육과 지식에 방대한 차이를 강조하고 있습니다. 기술 산업이 한 번 더 대부분의 소프트웨어 개발자와 프로그래머의 교육에 이러한 막다른 상황과 파괴적인 양식을 이끌었음을 한번 더 보여주고 있습니다.